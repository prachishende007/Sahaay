
-- Enable PostGIS extension for geographic data
CREATE EXTENSION IF NOT EXISTS postgis WITH SCHEMA extensions;

-- Drop existing tables if they exist (clean slate)
DROP TABLE IF EXISTS complaints CASCADE;
DROP TABLE IF EXISTS create_complaint CASCADE;
DROP TABLE IF EXISTS get_complaint CASCADE;
DROP TABLE IF EXISTS get_all_complaints CASCADE;
DROP TABLE IF EXISTS assign_complaint CASCADE;
DROP TABLE IF EXISTS get_db CASCADE;

-- Create the main complaints table matching your SQLAlchemy model
CREATE TABLE complaints (
    id TEXT PRIMARY KEY,  -- UUID as string (matches your model)
    description TEXT NOT NULL,
    lat FLOAT NOT NULL,
    lon FLOAT NOT NULL,
    category TEXT,
    status TEXT DEFAULT 'submitted',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    media_url TEXT,
    assigned_to TEXT,  -- staff_id
    feedback_rating FLOAT,
    feedback_comment TEXT
);

-- Add geographic point column using PostGIS for spatial queries
ALTER TABLE complaints 
ADD COLUMN location GEOGRAPHY(POINT, 4326);

-- Create a trigger to automatically populate the location column from lat/lon
CREATE OR REPLACE FUNCTION update_location()
RETURNS TRIGGER AS $$
BEGIN
    NEW.location = ST_SetSRID(ST_MakePoint(NEW.lon, NEW.lat), 4326)::GEOGRAPHY;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER complaints_location_trigger
    BEFORE INSERT OR UPDATE OF lat, lon ON complaints
    FOR EACH ROW
    EXECUTE FUNCTION update_location();

-- Create indexes for better performance
CREATE INDEX idx_complaints_status ON complaints(status);
CREATE INDEX idx_complaints_category ON complaints(category);
CREATE INDEX idx_complaints_assigned_to ON complaints(assigned_to);
CREATE INDEX idx_complaints_created_at ON complaints(created_at);
CREATE INDEX idx_complaints_location ON complaints USING GIST(location);

-- Add constraints for valid status values
ALTER TABLE complaints 
ADD CONSTRAINT valid_status 
CHECK (status IN ('submitted', 'in_review', 'in_progress', 'resolved'));

-- Add constraint for valid rating range
ALTER TABLE complaints 
ADD CONSTRAINT valid_rating 
CHECK (feedback_rating IS NULL OR (feedback_rating >= 0 AND feedback_rating <= 5));

-- Create a function to generate UUID (if not using application-level UUID generation)
CREATE OR REPLACE FUNCTION generate_complaint_id()
RETURNS TEXT AS $$
BEGIN
    RETURN gen_random_uuid()::TEXT;
END;
$$ LANGUAGE plpgsql;

-- Create RLS (Row Level Security) policies if needed
-- Uncomment and modify based on your authentication requirements

-- Enable RLS on the complaints table
-- ALTER TABLE complaints ENABLE ROW LEVEL SECURITY;

-- Example policy: Allow all operations for authenticated users
-- CREATE POLICY "Allow all operations for authenticated users" ON complaints
--     FOR ALL USING (auth.role() = 'authenticated');

-- Example policy: Allow public read access
-- CREATE POLICY "Allow public read access" ON complaints
--     FOR SELECT USING (true);

-- Create views for common queries (optional but useful)

-- View for analytics summary
CREATE OR REPLACE VIEW complaint_analytics AS
SELECT 
    COUNT(*) as total_complaints,
    COUNT(CASE WHEN status = 'resolved' THEN 1 END) as resolved_count,
    COUNT(CASE WHEN status = 'in_progress' THEN 1 END) as in_progress_count,
    COUNT(CASE WHEN status = 'submitted' THEN 1 END) as submitted_count,
    COUNT(CASE WHEN status = 'in_review' THEN 1 END) as in_review_count,
    COUNT(CASE WHEN category = 'Road Issue' THEN 1 END) as road_issues,
    COUNT(CASE WHEN category = 'Water Supply' THEN 1 END) as water_issues,
    COUNT(CASE WHEN category = 'Other' THEN 1 END) as other_issues,
    AVG(feedback_rating) as average_rating,
    COUNT(CASE WHEN feedback_rating IS NOT NULL THEN 1 END) as total_feedback
FROM complaints;

-- View for complaints with distance calculation (useful for location-based queries)
CREATE OR REPLACE VIEW complaints_with_location AS
SELECT 
    id,
    description,
    lat,
    lon,
    category,
    status,
    created_at,
    media_url,
    assigned_to,
    feedback_rating,
    feedback_comment,
    location
FROM complaints;

-- Function to find nearby complaints (within specified distance in meters)
CREATE OR REPLACE FUNCTION get_nearby_complaints(
    input_lat FLOAT,
    input_lon FLOAT,
    radius_meters INT DEFAULT 1000
)
RETURNS TABLE (
    id TEXT,
    description TEXT,
    lat FLOAT,
    lon FLOAT,
    category TEXT,
    status TEXT,
    created_at TIMESTAMP WITH TIME ZONE,
    media_url TEXT,
    assigned_to TEXT,
    feedback_rating FLOAT,
    feedback_comment TEXT,
    distance_meters FLOAT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        c.id,
        c.description,
        c.lat,
        c.lon,
        c.category,
        c.status,
        c.created_at,
        c.media_url,
        c.assigned_to,
        c.feedback_rating,
        c.feedback_comment,
        ST_Distance(
            c.location,
            ST_SetSRID(ST_MakePoint(input_lon, input_lat), 4326)::GEOGRAPHY
        ) as distance_meters
    FROM complaints c
    WHERE ST_DWithin(
        c.location,
        ST_SetSRID(ST_MakePoint(input_lon, input_lat), 4326)::GEOGRAPHY,
        radius_meters
    )
    ORDER BY distance_meters;
END;
$$ LANGUAGE plpgsql;

-- Insert some sample data for testing (optional)
-- You can uncomment this section to test your setup

INSERT INTO complaints (id, description, lat, lon, category) VALUES
    ('sample-1', 'Large pothole on main street', 18.5204, 73.8567, 'Road Issue'),
    ('sample-2', 'Water supply disruption in area', 18.5304, 73.8467, 'Water Supply'),
    ('sample-3', 'Street light not working', 18.5104, 73.8667, 'Other');


-- Grant necessary permissions (adjust based on your needs)
-- GRANT ALL ON complaints TO authenticated;
-- GRANT SELECT ON complaint_analytics TO authenticated;
-- GRANT EXECUTE ON FUNCTION get_nearby_complaints TO authenticated;

-- Show the created table structure
--\d complaints;

SELECT * FROM complaints ORDER BY created_at DESC LIMIT 10;
